/* This file is generated, do not edit! */
package unreal;
@:pythonImport("unreal", "WidgetInteractionComponent") extern class WidgetInteractionComponent extends unreal.SceneComponent {
	/**
		Initialize self.  See help(type(self)) for accurate signature.
	**/
	@:native("__init__")
	public function ___init__(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Dynamic;
	/**
		Initialize self.  See help(type(self)) for accurate signature.
	**/
	public function new(?args:python.VarArgs<Dynamic>, ?kwargs:python.KwArgs<Dynamic>):Void;
	/**
		(LinearColor):  [Read-Write] Determines the color of the debug lines.
	**/
	public var debug_color : unreal.LinearColor;
	/**
		(float):  [Read-Write] Determines the thickness of the debug lines.
	**/
	public var debug_line_thickness : Float;
	/**
		(float):  [Read-Write] Determines the line thickness of the debug sphere.
	**/
	public var debug_sphere_line_thickness : Float;
	/**
		(bool):  [Read-Write] Should the interaction component perform hit testing (Automatic or Custom) and attempt to
		simulate hover - if you were going to emulate a keyboard you would want to turn this option off
		if the virtual keyboard was separate from the virtual pointer device and used a second interaction
		component.
	**/
	public var enable_hit_testing : Bool;
	/**
		x.get2d_hit_location() -> Vector2D
		Gets the last hit location on the widget in 2D, local pixel units of the render target.
		
		Returns:
		    Vector2D:
	**/
	public function get2d_hit_location():unreal.Vector2D;
	/**
		x.get_hovered_widget_component() -> WidgetComponent
		Get the currently hovered widget component.
		
		Returns:
		    WidgetComponent:
	**/
	public function get_hovered_widget_component():unreal.WidgetComponent;
	/**
		x.get_last_hit_result() -> HitResult
		Gets the last hit result generated by the component.  Returns the custom hit result if that was set.
		
		Returns:
		    HitResult:
	**/
	public function get_last_hit_result():unreal.HitResult;
	/**
		(float):  [Read-Write] The distance in game units the component should be able to interact with a widget component.
	**/
	public var interaction_distance : Float;
	/**
		(WidgetInteractionSource):  [Read-Write] Should we project from the world location of the component?  If you set this to false, you'll
		need to call SetCustomHitResult(), and provide the result of a custom hit test form whatever
		location you wish.
	**/
	public var interaction_source : unreal.WidgetInteractionSource;
	/**
		x.is_over_focusable_widget() -> bool
		Returns true if a widget under the hit result is focusable.  e.g. Slate widgets that
		return true for SupportsKeyboardFocus().
		
		Returns:
		    bool:
	**/
	public function is_over_focusable_widget():Bool;
	/**
		x.is_over_hit_test_visible_widget() -> bool
		Returns true if a widget under the hit result is has a visibility that makes it hit test
		visible.  e.g. Slate widgets that return true for GetVisibility().IsHitTestVisible().
		
		Returns:
		    bool:
	**/
	public function is_over_hit_test_visible_widget():Bool;
	/**
		x.is_over_interactable_widget() -> bool
		Returns true if a widget under the hit result is interactive.  e.g. Slate widgets
		that return true for IsInteractable().
		
		Returns:
		    bool:
	**/
	public function is_over_interactable_widget():Bool;
	/**
		(OnHoveredWidgetChanged):  [Read-Write] Called when the hovered Widget Component changes.  The interaction component functions at the Slate
		level - so it's unable to report anything about what UWidget is under the hit result.
	**/
	public var on_hovered_widget_changed : unreal.OnHoveredWidgetChanged;
	/**
		(int32):  [Read-Write] Each user virtual controller or virtual finger tips being simulated should use a different pointer index.
	**/
	public var pointer_index : Int;
	/**
		x.press_and_release_key(key) -> bool
		Does both the press and release of a simulated keyboard key.
		
		Args:
		    key (Key): 
		
		Returns:
		    bool:
	**/
	public function press_and_release_key(key:Dynamic):Bool;
	/**
		x.press_key(key, repeat=False) -> bool
		Press a key as if it had come from the keyboard.  Avoid using this for 'a-z|A-Z', things like
		the Editable Textbox in Slate expect OnKeyChar to be called to signal a specific character being
		send to the widget.  So for those cases you should use SendKeyChar.
		
		Args:
		    key (Key): 
		    repeat (bool): 
		
		Returns:
		    bool:
	**/
	public function press_key(key:Dynamic, repeat:Dynamic):Bool;
	/**
		x.press_pointer_key(key) -> None
		Presses a key as if the mouse/pointer were the source of it.  Normally you would just use
		Left/Right mouse button for the Key.  However - advanced uses could also be imagined where you
		send other keys to signal widgets to take special actions if they're under the cursor.
		
		Args:
		    key (Key):
	**/
	public function press_pointer_key(key:Dynamic):Void;
	/**
		x.release_key(key) -> bool
		Releases a key as if it had been released by the keyboard.
		
		Args:
		    key (Key): 
		
		Returns:
		    bool:
	**/
	public function release_key(key:Dynamic):Bool;
	/**
		x.release_pointer_key(key) -> None
		Releases a key as if the mouse/pointer were the source of it.  Normally you would just use
		Left/Right mouse button for the Key.  However - advanced uses could also be imagined where you
		send other keys to signal widgets to take special actions if they're under the cursor.
		
		Args:
		    key (Key):
	**/
	public function release_pointer_key(key:Dynamic):Void;
	/**
		x.scroll_wheel(scroll_delta) -> None
		Sends a scroll wheel event to the widget under the last hit result.
		
		Args:
		    scroll_delta (float):
	**/
	public function scroll_wheel(scroll_delta:Dynamic):Void;
	/**
		x.send_key_char(characters, repeat=False) -> bool
		Transmits a list of characters to a widget by simulating a OnKeyChar event for each key listed in
		the string.
		
		Args:
		    characters (str): 
		    repeat (bool): 
		
		Returns:
		    bool:
	**/
	public function send_key_char(characters:Dynamic, repeat:Dynamic):Bool;
	/**
		x.set_custom_hit_result(hit_result) -> None
		Set custom hit result.  This is only taken into account if InteractionSource is set to EWidgetInteractionSource::Custom.
		
		Args:
		    hit_result (HitResult):
	**/
	public function set_custom_hit_result(hit_result:Dynamic):Void;
	/**
		x.set_focus(focus_widget) -> None
		Set the focus target of the virtual user managed by this component
		
		Args:
		    focus_widget (Widget):
	**/
	public function set_focus(focus_widget:Dynamic):Void;
	/**
		(bool):  [Read-Write] Shows some debugging lines and a hit sphere to help you debug interactions.
	**/
	public var show_debug : Bool;
	/**
		(CollisionChannel):  [Read-Write] The trace channel to use when tracing for widget components in the world.
	**/
	public var trace_channel : unreal.CollisionChannel;
	/**
		(int32):  [Read-Write] Represents the Virtual User Index.  Each virtual user should be represented by a different
		index number, this will maintain separate capture and focus states for them.  Each
		controller or finger-tip should get a unique PointerIndex.
	**/
	public var virtual_user_index : Int;
}